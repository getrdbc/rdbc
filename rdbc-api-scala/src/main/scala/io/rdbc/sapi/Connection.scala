/*
 * Copyright 2016 Krzysztof Pado
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.rdbc.sapi

import scala.concurrent.Future
import scala.concurrent.duration.FiniteDuration

/** Represents a database connection (session).
  *
  * Instances of implementations of this trait can be obtained using a [[ConnectionFactory]]. When clients are done
  * with the connection, they are required to call a `release` method co clean up resources such as open sockets.
  *
  * Invoking any method of this trait when any previous operation has not completed yet is not allowed. Operation is
  * considered complete when a resulting [[scala.concurrent.Future Future]] completes.
  *
  * Transaction management has to be done using `beginTx`, `commitTx` and `rollbackTx` methods. Using SQL statements to
  * manage transaction state is not allowed.
  *
  * SQL statements passed as this class method arguments can be parametrized using a following syntax:
  * Parameters are named. Parameter is comprised of an alphanumeric name prefixed with a colon. One parameter can
  * occur multiple times in one statement. Examples of valid statements are listed below:
  *  - `select * from users where login = :login`
  *  - `select * from users where login = :query or given_name = :query`
  *
  * @define timeoutInfo
  *  After the operation takes longer time than `timeout`, operation will be aborted. Note however, that it may not
  *  be feasible to abort the operation immediately.
  * @define statementExceptions
  *  Returned future can fail with:
  *  - [[io.rdbc.api.exceptions.SyntaxErrorException SyntaxErrorException]] - when statement is not syntactically correct
  *  - [[io.rdbc.api.exceptions.UncategorizedRdbcException UncategorizedRdbcException]] - when general error occurs
  * @define timeoutException
  *  - [[io.rdbc.api.exceptions.TimeoutException TimeoutException]] - when maximum operation time has been exceeded
  * @define bindExceptions
  *  - [[io.rdbc.api.exceptions.MissingParamValException MissingParamValException]] when some parameter value was not provided
  *  - [[io.rdbc.api.exceptions.NoSuitableConverterFoundException NoSuitableConverterFoundException]] when some parameter value's type is not convertible to a database type
  * @define statementParametrization
  *  For syntax of statement parametrization see a [[Connection]] documentation.
  * @define returningInsert
  *  Returns a [[ReturningInsert]] instance bound to this connection that represents a SQL insert statement that
  *  can return keys generated by the database engine.
  *
  *  It is not defined whether the method returns exceptionally if SQL provided is a valid statement,
  *  but not an insert statement.
  * @define interpolatorExample
  *  [[SqlAndParams]] parameter instance is meant to be constructed using `sql` string interpolator, for example:
  *  {{{
  *  import io.rdbc.sapi.Interpolators._
  *  val x = 1
  *  val y = 10
  *  val stmt = conn.select(sql"select * from table where colx > $x and coly < $y")
  *  }}}
  */
trait Connection {

  /** Begins a database transaction.
    *
    * Using this method is a preferred way of starting a transaction, using SQL statements to manage transaction
    * state may lead to undefined behavior.
    *
    * $timeoutInfo
    *
    * Returned future can fail with:
    *  - [[io.rdbc.api.exceptions.BeginTxException BeginTxException]] - when general error occurs
    * $timeoutException
    */
  def beginTx()(implicit timeout: FiniteDuration): Future[Unit]

  /** Commits a database transaction.
    *
    * Using this method is a preferred way of committing a transaction, using SQL statements to manage transaction
    * state may lead to undefined behavior.
    *
    * $timeoutInfo
    *
    * Returned future can fail with:
    *  - [[io.rdbc.api.exceptions.BeginTxException CommmitTxException]] - when general error occurs
    * $timeoutException
    */
  def commitTx()(implicit timeout: FiniteDuration): Future[Unit]

  /** Rolls back a database transaction.
    *
    * Using this method is a preferred way of rolling back a transaction, using SQL statements to manage transaction
    * state may lead to undefined behavior.
    *
    * $timeoutInfo
    *
    * Returned future can fail with:
    *  - [[io.rdbc.api.exceptions.BeginTxException RollbackTxException]] - when general error occurs
    * $timeoutException
    */
  def rollbackTx()(implicit timeout: FiniteDuration): Future[Unit]

  /** Releases the connection and underlying resources.
    *
    * After calling this method no future operations on the instance are allowed.
    *
    * Returned future can fail with:
    *  - [[io.rdbc.api.exceptions.ConnectionReleaseException ConnectionReleaseException]] - when general error occurs
    */
  def release(): Future[Unit]

  /** Checks whether the connection is still usable.
    *
    * If checking takes longer than `timeout`, connection is considered unusable.
    *
    * @return Future of `true` iff connection is usable, `false` otherwise
    */
  def validate()(implicit timeout: FiniteDuration): Future[Boolean]

  /** Returns a [[Select]] instance bound to this connection that represents a SQL select statement.
    *
    * It is not defined whether the method returns exceptionally if SQL provided is a valid statement,
    * but not a select statement.
    *
    * $statementParametrization
    *
    * $statementExceptions
    */
  def select(sql: String): Future[Select]

  /** Returns a [[ParametrizedSelect]] instance bound to this connection that represents a parametrized SQL select
    * statement.
    *
    * It's a shortcut for calling `select` and then `bind`.
    *
    * $interpolatorExample
    *
    * $statementExceptions
    * $bindExceptions
    */
  def select(sqlWithParams: SqlAndParams): Future[ParametrizedSelect]

  /** Returns an [[Update]] instance bound to this connection that represents a SQL update statement.
    *
    * It is not defined whether the method returns exceptionally if SQL provided is a valid statement,
    * but not an update statement.
    *
    * $statementParametrization
    *
    * $statementExceptions
    */
  def update(sql: String): Future[Update]

  /** Returns a [[ParametrizedUpdate]] instance bound to this connection that represents a parametrized SQL update
    * statement.
    *
    * It's a shortcut for calling `update` and then `bind`.
    * $interpolatorExample
    *
    * $statementExceptions
    * $bindExceptions
    */
  def update(sqlWithParams: SqlAndParams): Future[ParametrizedUpdate]

  /** Returns an [[Insert]] instance bound to this connection that represents a SQL insert statement.
    *
    * It is not defined whether the method returns exceptionally if SQL provided is a valid statement,
    * but not an insert statement.
    *
    * $statementParametrization
    *
    * $statementExceptions
    */
  def insert(sql: String): Future[Insert]

  /** Returns a [[ParametrizedInsert]] instance bound to this connection that represents a parametrized SQL insert
    * statement.
    *
    * It's a shortcut for calling `insert` and then `bind`.
    *
    * $interpolatorExample
    *
    * $statementExceptions
    * $bindExceptions
    */
  def insert(sqlWithParams: SqlAndParams): Future[ParametrizedInsert]

  /** $returningInsert
    *
    * $statementParametrization
    *
    * $statementExceptions
    */
  def returningInsert(sql: String): Future[ReturningInsert]

  /** Returns a [[ParametrizedReturningInsert]] instance bound to this connection that represents a parametrized SQL
    * insert statement can return keys generated by the database engine
    *
    * It's a shortcut for calling `returningInsert` and then `bind`.
    *
    * $interpolatorExample
    *
    * $statementExceptions
    * $bindExceptions
    */
  def returningInsert(sqlWithParams: SqlAndParams): Future[ParametrizedReturningInsert]

  /** $returningInsert
    *
    * `keyColumns` parameter is used to list column names that database engine generates keys for. Only keys from these
    * columns will be returned to the client. This method is a more efficient version of `returningInsert(sql: String)`
    * method that returns all keys generated by the database engine.
    *
    * $statementParametrization
    *
    * $statementExceptions
    */
  def returningInsert(sql: String, keyColumns: String*): Future[ReturningInsert]

  /** Returns a [[Delete]] instance bound to this connection that represents a SQL delete statement.
    *
    * It is not defined whether the method returns exceptionally if SQL provided is a valid statement,
    * but not a delete statement.
    *
    * $statementParametrization
    *
    * $statementExceptions
    */
  def delete(sql: String): Future[Delete]

  /** Returns a [[ParametrizedDelete]] instance bound to this connection that represents a parametrized SQL delete
    * statement.
    *
    * It's a shortcut for calling `delete` and then `bind`.
    *
    * $interpolatorExample
    *
    * $statementExceptions
    * $bindExceptions
    */
  def delete(sqlWithParams: SqlAndParams): Future[ParametrizedDelete]

  /** Returns an [[AnyStatement]] instance bound to this connection that represents any SQL statement.
    *
    * Clients are encouraged to use `select`, `insert`, `update`, `delete` methods in favor of this generic method.
    *
    * $statementParametrization
    *
    * $statementExceptions
    */
  def statement(sql: String): Future[AnyStatement]

  /** Returns a [[AnyParametrizedStatement]] instance bound to this connection that represents any parametrized SQL
    * statement.
    *
    * Clients are encouraged to use `select`, `insert`, `update`, `delete` methods in favor of this generic method.
    *
    * It's a shortcut for calling `statement` and then `bind`.
    *
    * $interpolatorExample
    *
    * $statementExceptions
    * $bindExceptions
    */
  def statement(sqlWithParams: SqlAndParams): Future[AnyParametrizedStatement]

  /** Returns a future that is complete when this connection is idle and ready for accepting queries. */
  def watchForIdle: Future[this.type]
}
